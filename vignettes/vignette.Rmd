---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

library(Lab6)
library(profvis)

```


```{r}

# create data set
suppressWarnings(RNGversion(min(as.character(getRversion()),"3.5.3")))

set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 1000000
knapsack_objects <- data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)

```



## Brute force search
Question: How much time does it takes to run the algorithm for n = 16 objects?
```{r}

system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500))

```


## Dynamic programming
Question: How much time does it takes to run the algorithm for n = 500 objects?
```{r}

system.time(dynamic_knapsack(x = knapsack_objects[1:500,], W = 3500))

```


## Greedy heuristic
Question How much time does it takes to run the algorithm for n = 1000000 objects?
```{r}

system.time(greedy_knapsack(x = knapsack_objects, W = 3500))

```


## Profile your code and optimize your code

Optimize code such that it runs faster is an iterative process:\newline

1. Find biggest bottleneck (slowest part of the code).\newline
2. Try to eliminate it (may not successful but that's okay). \newline
3. Repeat until code is "fast enough". \newline


There exists a number of techniques to improve a code. So of them are: \newline

1. Look for existing solutions.\newline
2. Do less work.\newline
3. Vectorise.\newline
4. Parallelise.\newline
5. Avoid copies.\newline
6. Byte-code compile (Wickham, 2019). 



### Brute force alogrithm
```{r}

profvis({
  
  x = knapsack_objects[1:25,]
  W = 3500
  
  # check input variables
  stopifnot(is.data.frame(x), x>0, length(x)==2, names(x) == c("w","v"))
  stopifnot(is.numeric(W), W>0, length(W)==1)
  
  
  # initialize starting values
  n <- nrow(x)
  val <- x$v
  wei <- x$w
  
  m <- matrix(nrow = n+1, ncol = W+1)
  m[1,] <- 0
  m[,1] <- 0
  
  for(i in 1:n){    
    for(c in 0:W){ # c = capacity of knapsack
      
      if(wei[i] > c){
        m[i+1,c+1] <- m[i,c+1]
      } else {
        m[i+1,c+1] <- max(m[i,c+1], m[i,c+1 -wei[i]] + val[i])
      }
    }
  } 
  
  
  c <- c+1  
  i <- which.max(m[,c])
  elements <- length(n)
  k <- 1
  elements[k] <- i-1
  
  while(m[i,c]!=0 && c!=1 && i!=0){
    k <- k+1
    c <- (c-wei[i-1])
    i <- which(m[,c] == m[i-1,c])[1]
    elements[k] <- i-1
  }
  
  value <- round(m[n+1,W+1])
  elements <- sort(elements[which(elements>0)])
  list(value=value, elements=elements)
  
})

```
As expected take the for-loops and the while-loop most of the computation time.

```{r}


x = knapsack_objects[1:25,]
W = 3500

# check input variables
stopifnot(is.data.frame(x), x>0, length(x)==2, names(x) == c("w","v"))
stopifnot(is.numeric(W), W>0, length(W)==1)


# initialize starting values
n <- nrow(x)
val <- x$v
wei <- x$w

m <- matrix(nrow = n+1, ncol = W+1)
m[1,] <- 0
m[,1] <- 0
  

profvis({
  
  for(i in 1:n){    
    for(c in 0:W){ # c = capacity of knapsack
      
      if(wei[i] > c){
        m[i+1,c+1] <- m[i,c+1]
      } else {
        m[i+1,c+1] <- max(m[i,c+1], m[i,c+1 -wei[i]] + val[i]) # takes most of  the time
      } 
    }
  } 
})

```






### Dynamic alogrithm
```{r}

```

### Greedy algorithm
```{r}

```


Question: What performance gain could you get by trying to improving your code?
```{r}

```




## (*) Parallelize brute force search
Question: What performance gain could you get by parallelizing brute force search?
```{r}

# system.time(brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000))
# system.time(brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000, parallel = TRUE))

```


